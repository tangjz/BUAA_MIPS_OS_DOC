##操作系统第2次实验报告

####一、核心代码分析

实验二涉及到大量的代码分析，少量的代码补全。

######0. 常量、宏定义、已有函数分析
- 地址相关
	- BY2PG：Bytes to a page
	- PTE_V：页表项的Valid Bit
	- PTE_R：页表项的Dirty Bit
	- PDX(va)：一级页表号
	- PTX(va)：二级页表号
	- PTE_ADDR(pte)：页内偏移
	- PPN(va) & VPN(va)：地址转页号
	- ULIM：虚拟地址起始地址
	- PADDR(kva)：虚拟地址转物理地址
	- KADDR(pa)：物理地址转虚拟地址
	- bzero(b, len)：清空以b为起始的len字节内容
	- ROUND(a, n)：将a向上增加至n的倍数，需要确保n是2的幂次
	- ROUNDDOWN(a, n)：将a向下减小至n的倍数，需要确保n是2的幂次
- 队列相关
	- LIST_HEAD(name, type)：定义队头
	- LIST_HEAD_INITIALIZER(head)：缺省队头
	- LIST_ENTRY(type)：页表项队列
	- LIST_EMPTY(head)：队列是否为空
	- LIST_FIRST(head)：队列首元素地址
	- LIST_FOREACH(var, head, field)：利用变量var遍历head指向的队列，利用field属性进行迭代
	- LIST_INIT(head)：初始化队列
	- LIST_INSERT_AFTER(listelm, elm, field)：elm插入到listelm后面，利用field属性进行迭代
	- LIST_INSERT_BEFORE(listelm, elm, field)：elm插入到listelm前面，利用field属性进行迭代
	- LIST_INSERT_HEAD(head, elm, field)：elm插入到head指向的队列头，利用field属性进行迭代
	- LIST_NEXT(elm, field)：elm利用field属性得到的元素地址
	- LIST_REMOVE(elm, field)：将elm从队列中删除，利用field属性进行迭代
	- TAILQ_HEAD(name, type)：尾队列队头的声明
	- TAILQ_ENTRY(type)：尾队列元素的声明

######1. 初始化与内存相关的全局变量
通过对gexmul的观察可以basemem的值，再根据其值设定其他三个全局变量的值即可。
```c
void mips_detect_memory()
{
    basemem = 64 * 1024 * 1024;
    extmem = 0;
    maxpa = basemem;
    npage = maxpa / BY2PG;
}
```

######2. 初始化空闲物理页表队列
初始化空闲队列，将空闲内存起始地址按页表对齐，标记已经用于使用页表，然后将空闲页表加入队列即可。
```c
void page_init(void) {
    int i;
    LIST_INIT(&page_free_list);
    freemem = ROUND(freemem, BY2PG);
    for(i = 0; i < PPN(PADDR(freemem)); ++i)
        pages[i].pp_ref = 1;
    for(i = PPN(PADDR(freemem)); i < npage; ++i) {
        pages[i].pp_ref = 0;
        LIST_INSERT_HEAD(&page_free_list, &pages[i], pp_link);
    }
}
```
######3. 完善物理页表申请与释放操作
申请：尝试从空闲队列中取出一个页表并从中删去，将对应页表的信息初始化清空即可。
```c
int page_alloc(struct Page **pp) {
    struct Page *ppage_temp;
    if(LIST_EMPTY(&page_free_list)) {
        return -E_NO_MEM;
    }
    ppage_temp = LIST_FIRST(&page_free_list);
    LIST_REMOVE(ppage_temp, pp_link);
    bzero(ppage_temp, sizeof(struct Page));
    bzero(KADDR(page2pa(ppage_temp)), BY2PG);
    *pp = ppage_temp;
    return 0;
}
```
释放：将无页表项的页表加入空闲队列即可。
```c
void page_free(struct Page *pp) {
    if(pp -> pp_ref > 0)
        return;
    if(pp -> pp_ref == 0)
        LIST_INSERT_HEAD(&page_free_list, pp, pp_link);
    else
        panic("cgh:pp->pp_ref is less than zero\n");
}
```

######4. 实现地址转换与页表创建功能
虚存地址所对应的页表的页面不存在时：得到当前一级页表的编号，检查对应的二级页表是否存在，不存在的话是否**需要**创建，最后根据页内偏移返回对应页表项的地址。
```c
static Pte *boot_pgdir_walk(Pde *pgdir, u_long va, int create) {
    Pde *pgdir_entryp;
    Pte *pgtable, *pgtable_entry;
    pgdir_entryp = pgdir + PDX(va);
    pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));
    if(*pgdir_entryp == 0) {
        if(create == 0)
            return NULL;
        pgtable = alloc(BY2PG, BY2PG, 1);
        *pgdir_entryp = PADDR(pgtable) | PTE_V | PTE_R;
    }
    pgtable_entry = pgtable + PTX(va);
    return pgtable_entry;
}
```
在空闲链表初始化之后：得到当前一级页表的编号，检查对应的二级页表是否存在，不存在的话是否**有能力**创建，最后根据页内偏移返回对应页表项的地址。
```c
int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte) {
    Pde *pgdir_entryp;
    Pte *pgtable;
    struct Page *ppage;
    pgdir_entryp = pgdir + PDX(va);
    pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));
    if((*pgdir_entryp & PTE_V) == 0) {
        if(create == 0) {
            *ppte = NULL;
            return 0;
        }
        if(page_alloc(&ppage) != 0) {
            *ppte = NULL;
            return -E_NO_MEM;
        }
        pgtable = (Pte *)KADDR(page2pa(ppage));
        *pgdir_entryp = PADDR(pgtable) | PTE_V | PTE_R;
        ++(ppage -> pp_ref);
    }
    *ppte = pgtable + PTX(va);
    return 0;
}
```
######5. 建立地址映射
只考虑多块整页表的情况，将每个页表和对应的物理地址进行链接，并设置页表（包括页目录）的权限和合法性即可。
```c
void boot_map_segment(Pde *pgdir, u_long va, u_long size, u_long pa, int perm) {
    int i, va_temp;
    Pte *pgtable_entry;
    if(size % BY2PG > 0)
        return;
    for(i = 0; i < size; i += BY2PG) {
        pgtable_entry = boot_pgdir_walk(pgdir, va + i, 1);
        *pgtable_entry = (pa + i) | perm | PTE_V;
    }
    pgdir[PDX(va)] |= perm;
}
```

####二、实验思考题

######Thinking 2.1
> 我们注意到我们把宏函数的函数体写成了 **do { ***// ...*** } while(0)** 的形式，而不是仅仅写成形如 **{ ***// ...*** }** 的语句块，这样的写法好处是什么？

答：由于宏展开是编译器在编译时进行的一定程度上对源码的处理替换，它可以便于程序的控制，但错误的宏展开可能导致错误的运行结果或者是编译失败。为了保证宏展开后的原子性和适配能力，需要对宏进行良好的设计。对于宏函数，习惯上会在函数的末尾加上一个分号，如果使用题述中后者的写法，则会在写到`else`语句之前的位置时出现编译错误，原因是多余一个分号使编译器无法分析，改用题述中前者的写法恰好可以成功适配末尾的分号。

推荐看一下"<a href="https://onevcat.com/2014/01/black-magic-in-macro/">宏定义的黑魔法 - 宏菜鸟起飞手册</a>"这篇博文。

######Thinking 2.2

> 了解了二级页表页目录自映射的原理之后，我们知道，Win2k 内核的虚存管理也是采用了二级页表的形式，其页表所占的 **4M** 空间对应的虚存起始地址为 **0xC0000000**，那么，它的页目录的起始地址是多少呢？  

答：由于是二级页表映射，实际将 **4GB** 寻址空间划分为 **1M** 个页表，而 **0xC0000000** 对应的是第 **(0xC0000000 >> 12)=0x000C0000** 个页表，由于需要建立一级页目录到二级页表中的自映射，而每个页表项占 **4** 个字节，故第 **0x000C0000** 个页表的第 **0x000C0000** 项的起始地址是 **0xC0000000+(0x000C0000 << 2)=0xC00300000** ，因此页目录的第一项的起始地址是 **0xC00300000** 。

######Thinking 2.3

> 思考一下 **tlb_out** 汇编函数，结合代码阐述一下跳转到 **NOFOUND** 的流程？ 

答：结合代码注释如下
```
	mfc0 k1,CP0_ENTRYHI		#保存现场
	mtc0 a0,CP0_ENTRYHI		#存取虚拟页号(VPN)和地址空间标识符(ASID)信息
	nop
	tlbp					#在tlb中查找VPN,ASID都跟EntryHi寄存器中的相应域匹配的入口，并把相应表项的索引值存入Index寄存器，如果匹配失败，则将Index的最高位置为1
	nop
	mfc0 k0,CP0_INDEX		#调取Index值
	bltz k0,NOFOUND			#Index值最高位为1则失配
	nop
	mtc0 zero,CP0_ENTRYHI	#设置CP0为无异常
	mtc0 zero,CP0_ENTRYLO0	#设置CP0为无异常
	nop
	tlbwi					#根据Index来写tlb表项
	NOFOUND:
	mtc0 k1,CP0_ENTRYHI		#恢复现场
	j ra
	nop
```

####三、实验难点图示

实验过程中涉及的函数调用如下：

![alt lab2](https://raw.githubusercontent.com/tangjz/BUAA_MIPS_OS_DOC/master/img2.png)

其中较难理解的是`boot_pgdir_walk`和`pgdir_walk`，需要理解`Pde`和`Pte`的含义，这一点我是通过复习课件记住的。其他部分结合注释均较易理解。

####四、体会与感想
本次实验的难度增大体现在对多个函数的含义理解和互相调用之间的掌控上，在这次实验中对`grep`的需求明显地增多，经常需要对注释理解一段时间，所幸将代码逐步细化后再完善实现的效果不错，效率相对没有降低很多。

在阅读与理解代码的过程中，我查阅了一部分关于宏定义的资料，对上学期学习的TLB的内容也有所温习，并且将老师课上的内容逐步融汇贯通，学习能力有了一定提升。

经过同学的推荐，我使用了`Understand`工具，对代码的管理与检索能力有了较大提升，在后期编程实现中方便了许多。

####五、残留难点
除挑战性任务未完成外，本次暂无残留难点……
